<section>
    <h1>DÃ­a 7: IntroducciÃ³n a TanStack Query en Next.js App Router</h1>
    <p>MÃ³dulo de desarrollo Frontend</p>
    <p>ğŸ‘¨â€ğŸ« Docente: Imanol Villarreal</p>
</section>

<section>
    <h2>Agenda del DÃ­a ğŸ“…</h2>
    <ol>
        <li>IntroducciÃ³n a TanStack Query ğŸŒŸ</li>
        <li>ConfiguraciÃ³n de TanStack Query en Next.js âš™ï¸</li>
        <li>useQuery hook en profundidad ğŸ£</li>
        <li>Manejo de estados de carga y error ğŸš¦</li>
        <li>PaginaciÃ³n y scroll infinito ğŸ“œ</li>
        <li>Resumen y tarea ğŸ“</li>
    </ol>
</section>

<section>
    <h2>1. IntroducciÃ³n a TanStack Query ğŸŒŸ</h2>
    <ul>
        <li>Â¿QuÃ© es TanStack Query y por quÃ© usarlo? ğŸ¤”</li>
        <li>Ventajas sobre fetch y SWR ğŸ’ª</li>
        <li>Conceptos clave: Queries, Mutations, Invalidations ğŸ—ï¸</li>
        <li>Caching y sincronizaciÃ³n de estado del servidor ğŸ”„</li>
    </ul>
</section>

<section>
    <h2>Â¿QuÃ© es TanStack Query? ğŸ¤”</h2>
    <ul>
        <li>Biblioteca para gestiÃ³n de estado del servidor en React ğŸ“š</li>
        <li>Simplifica la obtenciÃ³n, caching y sincronizaciÃ³n de datos ğŸ”„</li>
        <li>Reduce significativamente el cÃ³digo boilerplate ğŸ“‰</li>
        <li>Optimiza el rendimiento y la experiencia del usuario ğŸš€</li>
    </ul>
    <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/react/react-original.svg" alt="React Logo"
         style="height: 50px;"/>
</section>

<section>
    <h2>InstalaciÃ³n de TanStack Query v5 en Next.js ğŸ“¦</h2>

    <h3>1. InstalaciÃ³n de paquetes</h3>
    <pre><code class="language-bash">npm install @tanstack/react-query@5</code></pre>

    <h3>2. InstalaciÃ³n opcional de DevTools</h3>
    <pre><code class="language-bash">npm install @tanstack/react-query-devtools@5</code></pre>

    <h3>Notas Importantes â„¹ï¸</h3>
    <ul>
        <li>AsegÃºrate de usar la versiÃ³n 5 de TanStack Query</li>
        <li>Las DevTools son opcionales pero muy Ãºtiles durante el desarrollo</li>
        <li>TanStack Query v5 requiere React 18 o superior</li>
    </ul>
</section>

<section>
    <h2>ConfiguraciÃ³n de TanStack Query v5 en Next.js (Parte 1) ğŸ› ï¸</h2>

    <h3>Crear Provider</h3>
    <p>Crea un archivo <code>app/providers/ReactQueryProvider.tsx</code>:</p>
    <pre><code class="language-typescript">
'use client'
import { QueryClientProvider, QueryClient } from '@tanstack/react-query'
import { useState } from 'react'

const ReactQueryProvider = ({ children }: { children: React.ReactNode }) => {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false,
          },
        },
      })
  )

  return (
    &lt;QueryClientProvider client={queryClient}&gt;{children}&lt;/QueryClientProvider&gt;
  )
}

export default ReactQueryProvider
            </code></pre>
</section>

<section>
    <h2>ConfiguraciÃ³n de TanStack Query v5 en Next.js (Parte 2) ğŸ”—</h2>

    <h3>IntegraciÃ³n en App Router</h3>
    <p>Actualiza <code>app/layout.tsx</code>:</p>
    <pre><code class="language-typescript">
import ReactQueryProvider from './providers/ReactQueryProvider'

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    &lt;html lang="en"&gt;
      &lt;body&gt;
        &lt;ReactQueryProvider&gt;
          {children}
        &lt;/ReactQueryProvider&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  )
}
            </code></pre>

    <h3>Notas Adicionales ğŸ“</h3>
    <ul>
        <li>El provider usa 'use client' para funcionar en el lado del cliente</li>
        <li>refetchOnWindowFocus estÃ¡ desactivado por defecto en esta configuraciÃ³n</li>
        <li>Puedes ajustar mÃ¡s opciones en defaultOptions segÃºn tus necesidades</li>
    </ul>
</section>

<section>
    <h2>Ventajas de TanStack Query ğŸ’ª</h2>
    <ul>
        <li>GestiÃ³n de estado del servidor declarativa ğŸ“¢</li>
        <li>Caching y deduplicaciÃ³n automÃ¡tica de solicitudes ğŸ—ƒï¸</li>
        <li>SincronizaciÃ³n y actualizaciÃ³n en segundo plano ğŸ”„</li>
        <li>Manejo de errores y reintentos integrado ğŸ› ï¸</li>
        <li>PaginaciÃ³n y carga infinita simplificadas ğŸ“œ</li>
        <li>Soporte nativo para TypeScript ğŸ“˜</li>
    </ul>
</section>

<section>
    <h2>PÃ¡gina con useEffect en Next.js App Router ğŸ”„</h2>
    <p>Archivo: <code>app/posts-use-effect/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React, { useEffect, useState } from 'react';

interface Post {
  id: number;
  title: string;
}

export default function PostsPageWithUseEffect() {
  const [posts, setPosts] = useState&lt;Post[]&gt;([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch');
        return res.json();
      })
      .then((data: Post[]) => {
        setPosts(data);
        setIsLoading(false);
      })
      .catch(err => {
        setError(err);
        setIsLoading(false);
      });
  }, []);

  if (isLoading) return &lt;div&gt;Cargando...&lt;/div&gt;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;

  return (
    &lt;&gt;
      &lt;h1&gt;Posts (usando useEffect)&lt;/h1&gt;
      &lt;ul&gt;
        {posts.map(post => (
          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
}
            </code></pre>
</section>

<section>
    <h2>PÃ¡gina con TanStack Query en Next.js App Router ğŸš€</h2>
    <p>Archivo: <code>app/posts-tanstack-query/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react';
import { useQuery } from '@tanstack/react-query';

interface Post {
  id: number;
  title: string;
}

async function fetchPosts(): Promise&lt;Post[]&gt; {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  if (!res.ok) throw new Error('Failed to fetch');
  return res.json();
}

export default function PostsPageWithTanStackQuery() {
  const { data: posts, isLoading, error } = useQuery&lt;Post[], Error&gt;({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });

  if (isLoading) return &lt;div&gt;Cargando...&lt;/div&gt;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;

  return (
    &lt;&gt;
      &lt;h1&gt;Posts (usando TanStack Query)&lt;/h1&gt;
      &lt;ul&gt;
        {posts?.map(post => (
          &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
}
            </code></pre>
</section>

<section>
    <h2>ComparaciÃ³n: useQuery vs useSWR ğŸ¥Š</h2>
    <p>Ejemplo: Obtener una lista de posts</p>
    <div style="display: flex; justify-content: space-between;">
        <div style="flex: 1; margin-right: 10px;">
            <h3>TanStack Query (useQuery)</h3>
            <pre><code class="language-typescript">
import { useQuery } from '@tanstack/react-query';

const fetchPosts = async () => {
  const res = await fetch('https://api.example.com/posts');
  if (!res.ok) throw new Error('Error fetching posts');
  return res.json();
};

function Posts() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {data.map(post => (
        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
                    </code></pre>
        </div>
        <div style="flex: 1; margin-left: 10px;">
            <h3>SWR (useSWR)</h3>
            <pre><code class="language-typescript">
import useSWR from 'swr';

const fetchPosts = async () => {
  const res = await fetch('https://api.example.com/posts');
  if (!res.ok) throw new Error('Error fetching posts');
  return res.json();
};

function Posts() {
  const { data, error } = useSWR('posts', fetchPosts);

  if (!data) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;ul&gt;
      {data.map(post => (
        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
                    </code></pre>
        </div>
    </div>
</section>

<section>
    <h2>Ventajas de TanStack Query sobre useEffect ğŸ†</h2>
    <ul>
        <li>CÃ³digo mÃ¡s limpio y declarativo ğŸ“</li>
        <li>Manejo automÃ¡tico de estados de carga y error ğŸš¦</li>
        <li>Caching out-of-the-box ğŸ—ƒï¸</li>
        <li>RevalidaciÃ³n y refetch automÃ¡ticos ğŸ”„</li>
        <li>DeduplicaciÃ³n de solicitudes ğŸ­</li>
        <li>Optimizaciones de rendimiento integradas ğŸš€</li>
    </ul>
</section>


<section>
    <h2>3. useQuery hook en profundidad ğŸ£</h2>
    <ul>
        <li>Estructura bÃ¡sica de useQuery</li>
        <li>Claves de consulta y su importancia</li>
        <li>Opciones de configuraciÃ³n comunes</li>
        <li>Refetch y polling</li>
    </ul>
</section>

<section>
    <h2>Ejemplo bÃ¡sico de useQuery ğŸŒŸ</h2>
    <pre><code class="language-typescript">
import { useQuery } from '@tanstack/react-query'

const fetchPosts = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  if (!res.ok) throw new Error('Network response was not ok')
  return res.json()
}

function PostList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  })

  if (isLoading) return &lt;div&gt;Cargando...&lt;/div&gt;
  if (error) return &lt;div&gt;Error al cargar los posts: {error.message}&lt;/div&gt;

  return (
    &lt;ul&gt;
      {data.map(post => (
        &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}
            </code></pre>
</section>

<section>
    <h2>Propiedades de useQuery Explicadas ğŸ”</h2>
    <pre><code class="language-typescript">
const { data, isLoading, error } = useQuery({
  queryKey: ['posts'],
  queryFn: fetchPosts,
})
            </code></pre>
    <ul>
        <li><strong>queryKey</strong> ğŸ”‘:
            <ul>
                <li>Array que identifica Ãºnicamente la consulta</li>
                <li>Se usa para caching y sincronizaciÃ³n</li>
                <li>Puede incluir variables que afecten el resultado (ej: ['posts', userId])</li>
            </ul>
        </li>
        <li><strong>queryFn</strong> ğŸ”„:
            <ul>
                <li>FunciÃ³n asÃ­ncrona que realiza la peticiÃ³n de datos</li>
                <li>Debe devolver una promesa</li>
                <li>Puede acceder a las variables del queryKey</li>
            </ul>
        </li>
        <li><strong>data</strong> ğŸ“Š:
            <ul>
                <li>Contiene los datos devueltos por queryFn</li>
                <li>Es undefined mientras la consulta estÃ¡ cargando o ha fallado</li>
            </ul>
        </li>
        <li><strong>isLoading</strong> â³:
            <ul>
                <li>Boolean que indica si la consulta estÃ¡ en proceso de carga</li>
                <li>Ãštil para mostrar estados de carga</li>
            </ul>
        </li>
        <li><strong>error</strong> âŒ:
            <ul>
                <li>Contiene el error si la consulta ha fallado</li>
                <li>Es null si la consulta fue exitosa o estÃ¡ cargando</li>
            </ul>
        </li>
    </ul>
</section>

<section>
    <h2>Opciones avanzadas de useQuery ğŸ› ï¸</h2>
    <pre><code class="language-typescript">
const { data, isLoading, error } = useQuery({
  queryKey: ['posts', userId],
  queryFn: async () => {
    const res = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userId}`)
    if (!res.ok) throw new Error('Network response was not ok')
    return res.json()
  },
  staleTime: 5 * 60 * 1000, // 5 minutos
  gcTime: 15 * 60 * 1000, // 15 minutos
  refetchOnWindowFocus: false,
  retry: 3,
})
            </code></pre>
</section>

<section><h2>Opciones Avanzadas de useQuery Explicadas ğŸ”¬</h2>
    <ul>
        <li><strong>queryKey</strong> ğŸ”‘:
            <ul>
                <li>['posts', userId]: Array que incluye variables dinÃ¡micas</li>
                <li>La consulta se actualiza automÃ¡ticamente cuando cambia userId</li>
            </ul>
        </li>
        <li><strong>queryFn</strong> ğŸ”„:
            <ul>
                <li>FunciÃ³n asÃ­ncrona que usa la variable userId del queryKey</li>
                <li>Manejo explÃ­cito de errores con verificaciÃ³n de res.ok</li>
            </ul>
        </li>
        <li><strong>staleTime</strong> â±ï¸:
            <ul>
                <li>Tiempo durante el cual los datos se consideran "frescos"</li>
                <li>5 minutos en este ejemplo</li>
                <li>Evita refetches innecesarios durante este perÃ­odo</li>
            </ul>
        </li>
        <li><strong>gcTime</strong> ğŸ—‘ï¸:
            <ul>
                <li>Tiempo que los datos inactivos permanecen en cachÃ©</li>
                <li>15 minutos en este ejemplo</li>
                <li>DespuÃ©s de este tiempo, los datos se eliminan si no se usan</li>
            </ul>
        </li>
        <li><strong>refetchOnWindowFocus</strong> ğŸªŸ:
            <ul>
                <li>Controla si se debe recargar al volver a enfocar la ventana</li>
                <li>false: desactiva esta caracterÃ­stica</li>
            </ul>
        </li>
        <li><strong>retry</strong> ğŸ”:
            <ul>
                <li>NÃºmero de intentos de reintento en caso de error</li>
                <li>3 intentos en este ejemplo</li>
            </ul>
        </li>
    </ul>
</section>

<!--<section>
    <h2>4. Descanso (10 minutos) â˜•</h2>
    <p>Â¡TÃ³mate un respiro y vuelve recargado!</p>
</section>-->

<section>
    <h2>5. Manejo de estados de carga y error ğŸš¦</h2>
    <ul>
        <li>Estados de la consulta: isLoading, isError, isSuccess</li>
        <li>Manejo de errores y reintentos</li>
        <li>Suspense mode en React Query</li>
        <li>Skeleton loaders y placeholders</li>
    </ul>
</section>

<section>
    <h2>Ejemplo de manejo de estados ğŸ­</h2>
    <p>Archivo: <code>app/posts/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react';
import { useQuery } from '@tanstack/react-query';
import {
  Container,
  Typography,
  List,
  ListItem,
  ListItemText,
  Skeleton,
  Alert,
  Box
} from '@mui/material';

interface Post {
  id: number;
  title: string;
}

const fetchPosts = async (): Promise&lt;Post[]&gt; => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  if (!res.ok) throw new Error('Failed to fetch posts');
  return res.json();
};

const PostListSkeleton = () => (
  &lt;Box&gt;
    {[...Array(5)].map((_, index) => (
      &lt;Skeleton key={index} height={60} sx={{ my: 1 }} /&gt;
    ))}
  &lt;/Box&gt;
);

const ErrorMessage = ({ message }: { message: string }) => (
  &lt;Alert severity="error" sx={{ mt: 2 }}&gt;{message}&lt;/Alert&gt;
);

export default function PostList() {
  const { data, isLoading, isError, error } = useQuery&lt;Post[], Error&gt;({
    queryKey: ['posts'],
    queryFn: fetchPosts,
  });

  return (
    &lt;Container maxWidth="md" sx={{ mt: 4 }}&gt;
      &lt;Typography variant="h4" component="h1" gutterBottom&gt;
        Lista de Posts
      &lt;/Typography&gt;

      {isLoading && &lt;PostListSkeleton /&gt;}

      {isError && &lt;ErrorMessage message={error.message} /&gt;}

      {data && (
        &lt;List&gt;
          {data.map(post => (
            &lt;ListItem key={post.id} divider&gt;
              &lt;ListItemText primary={post.title} /&gt;
            &lt;/ListItem&gt;
          ))}
        &lt;/List&gt;
      )}
    &lt;/Container&gt;
  );
}
            </code></pre>
</section>

<section>
    <h2>6. PaginaciÃ³n y scroll infinito ğŸ“œ</h2>
    <ul>
        <li>ImplementaciÃ³n de paginaciÃ³n con useQuery</li>
        <li>Scroll infinito con useInfiniteQuery</li>
        <li>Manejo de datos paginados en el cache</li>
        <li>Optimizaciones de rendimiento para listas largas</li>
    </ul>
</section>

<section>
    <h2>Ejemplo de PaginaciÃ³n ğŸ“„</h2>
    <p>Archivo: <code>app/posts/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React, { useState } from 'react'
import { useQuery } from '@tanstack/react-query'

interface Post {
  id: number
  title: string
}

const fetchPosts = async (page: number): Promise&lt;Post[]&gt; => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`)
  if (!res.ok) throw new Error('Network response was not ok')
  return res.json()
}

export default function PostList() {
  const [page, setPage] = useState(1)
  const { data, isLoading, error, isPlaceholderData } = useQuery({
    queryKey: ['posts', page],
    queryFn: () => fetchPosts(page),
    placeholderData: keepPreviousData,
  })

  if (isLoading) return &lt;div&gt;Cargando...&lt;/div&gt;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;

  return (
    &lt;div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}&gt;
      &lt;h1&gt;Lista de Posts (PÃ¡gina {page})&lt;/h1&gt;

      &lt;ul style={{ listStyle: 'none', padding: 0 }}&gt;
        {data?.map(post => (
          &lt;li key={post.id} style={{ borderBottom: '1px solid #ddd', padding: '10px 0' }}&gt;
            {post.title}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;

      &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '20px' }}&gt;
        &lt;button
          onClick={() => setPage(old => Math.max(old - 1, 1))}
          disabled={page === 1}
          style={{ padding: '10px 20px' }}
        &gt;
          Anterior
        &lt;/button&gt;
        &lt;button
          onClick={() => setPage(old => old + 1)}
          disabled={isPlaceholderData || (data && data.length &lt; 10)}
          style={{ padding: '10px 20px' }}
        &gt;
          Siguiente
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
            </code></pre>
</section>

<section>
    <h2>PaginaciÃ³n con MUI y TanStack Query v5 ğŸ“š</h2>
    <p>Archivo: <code>app/posts/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import {
  Container,
  Typography,
  Card,
  CardContent,
  Grid,
  Pagination,
  CircularProgress,
  Alert
} from '@mui/material'

interface Post {
  id: number;
  title: string;
  body: string;
}

async function fetchPosts(page: number): Promise&lt;Post[]&gt; {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`)
  if (!res.ok) throw new Error('Failed to fetch posts')
  return res.json()
}

export default function PostList() {
  const [page, setPage] = useState(1)
  const { data, isLoading, error, isPlaceholderData } = useQuery({
    queryKey: ['posts', page],
    queryFn: () => fetchPosts(page),
    placeholderData: keepPreviousData,
  })

  const handleChange = (event: React.ChangeEvent&lt;unknown&gt;, value: number) => {
    setPage(value);
  };

  if (isLoading) return &lt;CircularProgress /&gt;
  if (error) return &lt;Alert severity="error"&gt;Error: {error.message}&lt;/Alert&gt;

  return (
    &lt;Container maxWidth="md" sx={{ py: 4 }}&gt;
      &lt;Typography variant="h4" component="h1" gutterBottom&gt;
        Lista de Posts
      &lt;/Typography&gt;
      &lt;Grid container spacing={3}&gt;
        {data?.map(post => (
          &lt;Grid item xs={12} key={post.id}&gt;
            &lt;Card&gt;
              &lt;CardContent&gt;
                &lt;Typography variant="h6" component="h2"&gt;
                  {post.title}
                &lt;/Typography&gt;
                &lt;Typography variant="body2" color="text.secondary"&gt;
                  {post.body}
                &lt;/Typography&gt;
              &lt;/CardContent&gt;
            &lt;/Card&gt;
          &lt;/Grid&gt;
        ))}
      &lt;/Grid&gt;
      &lt;Pagination
        count={10}
        page={page}
        onChange={handleChange}
        sx={{ mt: 4, display: 'flex', justifyContent: 'center' }}
        disabled={isPlaceholderData}
      /&gt;
    &lt;/Container&gt;
  )
}
            </code></pre>
</section>

<section>
    <h2>Ejemplo de Scroll Infinito en Next.js ğŸ”„</h2>
    <p>Archivo: <code>app/posts/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react'
import { useInfiniteQuery } from '@tanstack/react-query'
import InfiniteScroll from 'react-infinite-scroll-component'

interface Post {
  id: number
  title: string
}

const fetchPosts = async ({ pageParam = 1 }): Promise&lt;Post[]&gt; => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts?_page=${pageParam}&_limit=10`)
  if (!res.ok) throw new Error('Network response was not ok')
  return res.json()
}

export default function InfinitePostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isLoading,
    isFetching,
    error
  } = useInfiniteQuery&lt;Post[]&gt;({
    queryKey: ['posts'],
    queryFn: fetchPosts,
    getNextPageParam: (lastPage, pages) => lastPage.length === 10 ? pages.length + 1 : undefined,
  })

  if (isLoading) return &lt;div&gt;Cargando posts iniciales...&lt;/div&gt;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;

  return (
    &lt;div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}&gt;
      &lt;h1&gt;Lista Infinita de Posts&lt;/h1&gt;
      &lt;InfiniteScroll
        dataLength={data?.pages.flatMap(page => page).length ?? 0}
        next={fetchNextPage}
        hasMore={hasNextPage ?? false}
        loader={&lt;h4&gt;Cargando mÃ¡s posts...&lt;/h4&gt;}
        endMessage={&lt;p style={{ textAlign: 'center' }}&gt;&lt;b&gt;Â¡Has visto todos los posts!&lt;/b&gt;&lt;/p&gt;}
      &gt;
        {data?.pages.flatMap(page =>
          page.map(post => (
            &lt;div key={post.id} style={{
              border: '1px solid #ddd',
              borderRadius: '4px',
              padding: '10px',
              marginBottom: '10px'
            }}&gt;
              &lt;h3&gt;{post.title}&lt;/h3&gt;
            &lt;/div&gt;
          ))
        )}
      &lt;/InfiniteScroll&gt;
      {isFetching && !isLoading ? &lt;div&gt;Actualizando en segundo plano...&lt;/div&gt; : null}
    &lt;/div&gt;
  )
}
            </code></pre>
</section>

<section>
    <h2>PÃ¡gina PÃºblica de Noticias con useQuery ğŸ“°</h2>
    <p>Archivo: <code>app/news/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react';
import {
  Container,
  Typography,
  Grid,
  Card,
  CardContent,
  CardMedia,
  Button,
  CircularProgress,
  Alert
} from '@mui/material';
import Link from 'next/link';
import { useQuery } from '@tanstack/react-query';

interface News {
  id: number;
  title: string;
  description: string;
  imageUrl: string;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL;

const fetchNews = async (): Promise&lt;News[]&gt; => {
  const res = await fetch(`${API_URL}/news`);
  if (!res.ok) {
    throw new Error('Failed to fetch news');
  }
  return res.json();
};

export default function NewsPage() {
  const { data: news, isLoading, error } = useQuery&lt;News[], Error&gt;({
    queryKey: ['news'],
    queryFn: fetchNews,
  });

  if (isLoading) return &lt;CircularProgress /&gt;;
  if (error) return &lt;Alert severity="error"&gt;Error: {error.message}&lt;/Alert&gt;;

  return (
    &lt;Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}&gt;
      &lt;Typography variant="h2" component="h1" gutterBottom&gt;
        Ãšltimas Noticias
      &lt;/Typography&gt;
      &lt;Grid container spacing={4}&gt;
        {news?.map((item) =&gt; (
          &lt;Grid item xs={12} sm={6} md={4} key={item.id}&gt;
            &lt;Card&gt;
              &lt;CardMedia
                component="img"
                height="140"
                image={item.imageUrl}
                alt={item.title}
              /&gt;
              &lt;CardContent&gt;
                &lt;Typography gutterBottom variant="h5" component="div"&gt;
                  {item.title}
                &lt;/Typography&gt;
                &lt;Typography variant="body2" color="text.secondary"&gt;
                  {item.description.substring(0, 100)}...
                &lt;/Typography&gt;
                &lt;Link href={`/news/${item.id}`} passHref legacyBehavior&gt;
                  &lt;Button variant="contained" color="primary" sx={{ mt: 2 }}&gt;
                    Leer mÃ¡s
                  &lt;/Button&gt;
                &lt;/Link&gt;
              &lt;/CardContent&gt;
            &lt;/Card&gt;
          &lt;/Grid&gt;
        ))}
      &lt;/Grid&gt;
    &lt;/Container&gt;
  );
}
            </code></pre>
</section>

<section>
    <h2>PÃ¡gina PÃºblica de Noticias con Scroll Infinito ğŸ“œ</h2>
    <p>Archivo: <code>app/news/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react';
import {
  Container,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  CircularProgress,
  Alert,
  Box
} from '@mui/material';
import Link from 'next/link';
import { useInfiniteQuery } from '@tanstack/react-query';
import InfiniteScroll from 'react-infinite-scroll-component';

interface News {
  id: number;
  title: string;
  description: string;
  date: string;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL;
const PAGE_SIZE = 10;

const fetchNews = async ({ pageParam = 1 }): Promise&lt;News[]&gt; => {
  const res = await fetch(`${API_URL}/news?pageSize=${PAGE_SIZE}&page=${pageParam}`);
  if (!res.ok) {
    throw new Error('Failed to fetch news');
  }
  return res.json();
};

export default function NewsPage() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isLoading,
    isError,
    error
  } = useInfiniteQuery&lt;News[], Error&gt;({
    queryKey: ['news'],
    queryFn: fetchNews,
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length === PAGE_SIZE ? allPages.length + 1 : undefined;
    },
  });

  if (isLoading) return &lt;CircularProgress /&gt;;
  if (isError) return &lt;Alert severity="error"&gt;Error: {error.message}&lt;/Alert&gt;;

  const news = data?.pages.flat() || [];

  return (
    &lt;Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}&gt;
      &lt;Typography variant="h2" component="h1" gutterBottom&gt;
        Ãšltimas Noticias
      &lt;/Typography&gt;
      &lt;InfiniteScroll
        dataLength={news.length}
        next={fetchNextPage}
        hasMore={!!hasNextPage}
        loader={&lt;Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}&gt;&lt;CircularProgress /&gt;&lt;/Box&gt;}
      &gt;
        &lt;Grid container spacing={4}&gt;
          {news.map((item) =&gt; (
            &lt;Grid item xs={12} sm={6} md={4} key={item.id}&gt;
              &lt;Card&gt;
                &lt;CardContent&gt;
                  &lt;Typography gutterBottom variant="h5" component="div"&gt;
                    {item.title}
                  &lt;/Typography&gt;
                  &lt;Typography variant="body2" color="text.secondary"&gt;
                    {item.description.substring(0, 100)}...
                  &lt;/Typography&gt;
                  &lt;Typography variant="caption" display="block" sx={{ mt: 1 }}&gt;
                    {new Date(item.date).toLocaleDateString()}
                  &lt;/Typography&gt;
                  &lt;Link href={`/news/${item.id}`} passHref legacyBehavior&gt;
                    &lt;Button variant="contained" color="primary" sx={{ mt: 2 }}&gt;
                      Leer mÃ¡s
                    &lt;/Button&gt;
                  &lt;/Link&gt;
                &lt;/CardContent&gt;
              &lt;/Card&gt;
            &lt;/Grid&gt;
          ))}
        &lt;/Grid&gt;
      &lt;/InfiniteScroll&gt;
    &lt;/Container&gt;
  );
}
            </code></pre>
</section>

<section>
    <h2>Dashboard con useQuery ğŸ“Š</h2>
    <p>Archivo: <code>app/admin/page.tsx</code></p>
    <pre><code class="language-typescript">
'use client'

import React from 'react';
import { useAuth } from '../context/AuthContext';
import { Container, Typography, List, ListItem, ListItemText, Button, Box, CircularProgress, Alert } from '@mui/material';
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';
import Cookies from 'js-cookie';

interface News {
    id: number;
    title: string;
}

const API_URL = process.env.NEXT_PUBLIC_API_URL;

const fetchNews = async (): Promise&lt;News[]&gt; => {
    const response = await axios.get(`${API_URL}/news`, {
        headers: {
            Authorization: `Bearer ${Cookies.get('token')}`
        }
    });
    return response.data;
};

const Dashboard: React.FC = () => {
    const { user } = useAuth();

    const { data: news, isLoading, error } = useQuery&lt;News[], Error&gt;({
        queryKey: ['news'],
        queryFn: fetchNews,
    });

    const addNews = async () => {
        // ImplementaciÃ³n futura
        console.log('Agregar noticia');
    };

    const updateNews = async (id: number) => {
        // ImplementaciÃ³n futura
        console.log('Actualizar noticia', id);
    };

    const deleteNews = async (id: number) => {
        // ImplementaciÃ³n futura
        console.log('Eliminar noticia', id);
    };

    if (isLoading) return &lt;CircularProgress /&gt;;
    if (error) return &lt;Alert severity="error"&gt;Error: {error.message}&lt;/Alert&gt;;

    return (
        &lt;Container maxWidth="md"&gt;
            &lt;Box sx={{ my: 4 }}&gt;
                &lt;Typography variant="h4" component="h1" gutterBottom&gt;
                    Bienvenido, {user?.username}!
                &lt;/Typography&gt;
                &lt;Typography variant="h5" component="h2" gutterBottom&gt;
                    GestiÃ³n de Noticias
                &lt;/Typography&gt;
                &lt;Button variant="contained" color="primary" onClick={addNews} sx={{ mb: 2 }}&gt;
                    Agregar Noticia
                &lt;/Button&gt;
                &lt;List&gt;
                    {news?.map((item) => (
                        &lt;ListItem key={item.id} sx={{ bgcolor: 'background.paper', mb: 1, borderRadius: 1 }}&gt;
                            &lt;ListItemText primary={item.title} /&gt;
                            &lt;Button onClick={() => updateNews(item.id)} color="info" sx={{ mr: 1 }}&gt;Actualizar&lt;/Button&gt;
                            &lt;Button onClick={() => deleteNews(item.id)} color="error"&gt;Eliminar&lt;/Button&gt;
                        &lt;/ListItem&gt;
                    ))}
                &lt;/List&gt;
            &lt;/Box&gt;
        &lt;/Container&gt;
    );
};

export default Dashboard;
            </code></pre>
</section>


<section>
    <h2>Resumen ğŸ“</h2>
    <ul>
        <li>TanStack Query simplifica la gestiÃ³n del estado del servidor ğŸš€</li>
        <li>useQuery proporciona una API poderosa para fetching de datos ğŸ’ª</li>
        <li>El manejo de estados de carga y error es mÃ¡s sencillo con TanStack Query ğŸš¦</li>
        <li>La paginaciÃ³n y el scroll infinito se implementan fÃ¡cilmente ğŸ“œ</li>
        <li>Mejora significativa en la experiencia del desarrollador y del usuario ğŸ˜Š</li>
    </ul>
</section>

<section>
    <h2>ComparaciÃ³n final: TanStack Query vs Alternativas ğŸ¥Š</h2>
    <table>
        <thead>
        <tr>
            <th>CaracterÃ­stica</th>
            <th>TanStack Query</th>
            <th>useEffect + fetch</th>
            <th>SWR</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>Caching automÃ¡tico</td>
            <td>âœ…</td>
            <td>âŒ</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>RevalidaciÃ³n automÃ¡tica</td>
            <td>âœ…</td>
            <td>âŒ</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>PaginaciÃ³n/Scroll infinito</td>
            <td>âœ… (FÃ¡cil)</td>
            <td>âœ… (Manual)</td>
            <td>âœ…</td>
        </tr>
        <tr>
            <td>Devtools</td>
            <td>âœ…</td>
            <td>âŒ</td>
            <td>âŒ</td>
        </tr>
        <tr>
            <td>Manejo de mutaciones</td>
            <td>âœ…</td>
            <td>âŒ</td>
            <td>âœ… (Limitado)</td>
        </tr>
        </tbody>
    </table>
</section>

<!--<section>
    <h2>Tarea ğŸ“š</h2>
    <p>Implementar TanStack Query en la aplicaciÃ³n de administraciÃ³n de productos:</p>
    <ul>
        <li>Reemplazar las llamadas fetch existentes por useQuery ğŸ”„</li>
        <li>Implementar una lista paginada de productos ğŸ“„</li>
        <li>AÃ±adir un componente de bÃºsqueda que utilice useQuery ğŸ”</li>
        <li>Implementar scroll infinito en la pÃ¡gina de catÃ¡logo ğŸ”„</li>
        <li>Utilizar placeholders durante la carga de datos â³</li>
        <li>Manejar y mostrar errores de forma adecuada âš ï¸</li>
    </ul>
</section>-->

<section>
    <h2>Recursos adicionales ğŸ“š</h2>
    <ul>
        <li>
            <a href="https://tanstack.com/query/latest" target="_blank">DocumentaciÃ³n oficial de TanStack Query</a>
        </li>
        <li>
            <a href="https://github.com/TanStack/query/tree/main/examples" target="_blank">Ejemplos oficiales de
                TanStack Query</a>
        </li>
        <li>
            <a href="https://react-query.tanstack.com/comparison" target="_blank">ComparaciÃ³n con otras librerÃ­as</a>
        </li>
        <li>
            <a href="https://www.youtube.com/watch?v=novnyCaa7To" target="_blank">Tutorial en video de TanStack
                Query</a>
        </li>
    </ul>
</section>

<section>
    <h2>Â¡Gracias! ğŸ™</h2>
    <p>Â¿Preguntas?</p>
</section>
